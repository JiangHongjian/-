最小重量机器设计问题
问题描述：设某一机器由n个部件组成，每一种部件都可以从m个不同的供应商处购得。设wij是从供应商j处够来的部件i的重量，cij是相应的价格。
试设计一个算法，给出总价格不超过c的最小重量机器设计。
    算法设计：对于给定的机器部件重量和机器部件价格，计算总价值不超过d的最小重量机器设计。
    数据输入：第一行由3个正整数n，m，d。接下来的2n行，每行m个数。前n行是c，后n行是w。
     结果输出:将计算的最小重量及每个部件的供应商输出。
输入：
3 3 4
  1 2 3
3 2 1
2 2 2
1 2 3
3 2 1
2 2 2
  输出：
4
1 3 1

2、解题思路： 
     由于题目已经给出总价格的上限，因此算法通过使用回溯来选择合适的机器使得在总价格不超过d时得到的机器重量最小。首先初始化当前价格cp=0,当前重量cw=0,此外，还要设置一个变量bestw表示选择机器的总重量，初始化其为每个部件从1号供应商购买的重量。在循环选择i号机器时，判断从j号供应商购买机器后的价格是否大于总价格，如果不大于则选择，否则不选，继续选择下一供应商进行判断。在得到一个合适的供应商后，继续选择下一机器的供应商，从第一个选到最后一个供应商。当所有机器选择结束后，判断得到的总重量是否比之前的bestw小，如果小就赋给bestw，然后从这一步开始，回溯到上一机器，选择下一合适供应商，继续搜索可行解，直到将整个排列树搜索完毕。这样，最终得到的bestw即为最优解。 
     当然，考虑到算法的时间复杂度，还可以加上一个剪枝条件，即在每次选择某一机器时，再判断选择后的当前重量是否已经大于之前的bestw，如果大于就没必要继续搜索了，因为得到的肯定不是最优解。 

3、算法设计： 
a.部件有n个，供应商有m个，分别用array2[i][j]和array1[i][j]存储从供应商j 处购得的部件i的重量和相应价格，d为总价格的上限。 
b.用递归函数machine(i)来实现回溯法搜索排列树（形式参数i表示递归深度）。 
  ① 若cp>d，则为不可行解，剪去相应子树，返回到i-1层继续执行。 
  ② 若cw>=bestw，则不是最优解，剪去相应子树，返回到i-1层继续执行。 
  ③ 若i>n，则算法搜索到一个叶结点，用bestw对最优解进行记录，返回到i-1层继续执行； 
  ④ 用for循环对部件i从m个不同的供应商购得的情况进行选择(1≤j≤m）。 
c.主函数调用一次machine(1)即可完成整个回溯搜索过程，最终得到的bestw即为所求最小总重量。 

4.算法时间复杂度： 
    程序中最大的循环出现在递归函数Backtrack(int t)中，而此函数遍历排列树的时间复杂度为O(n!),故该算法的时间复杂度为O(n!)。 
    
#include<iostream>
#include<stdio.h>
using namespace std;
int w[100][100];//w[i][j]为第i个零件在第j个供应商的重量
int c[100][100];//c[i][j]为第i个零件在第j个供应商的价格
int bestx[100];//bestx[i]表示一次搜索到底后的最优解，用来存放第i个零件的供应商，
int x[100];//x[i]临时存放第i个零件的供应商
int cw=0,cc=0,bestw=10000;//bestw为当前最小重量
int cost;//限定价格
int n;//部件数
int m;//供应商数
void Backtrack(int t)//回溯法，参数int t
{
    int j;//定义变量j
    if(t>n)//搜索到叶子结点，一个搜索结束，所有零件已经找完
    {
        bestw=cw;//当前最小重量置为0
        for(j=1;j<=n;j++)
            bestx[j]=x[j];//则这个叶子节点的值就是要找的最小重量
    }
    else
    {
        for(j=1;j<=m;j++)//j小于供应商m，则+1，遍历供应商
        {
            if(cc+c[t][j]<=cost && cw+w[t][j]<bestw)//当前花费+该叶子节点j供应商下的费用<=限定价格 （且）当前重量+第j个供应商下的重量<当前最小重量 
            {
                x[t]=j;
                cc+=c[t][j];//经过Backtrack迭代后，j供应商下的价格累加至全局变量cc中
                cw+=w[t][j];//经过Backtrack迭代后，j供应商下的重量累加至全局变量cw中
                Backtrack(t+1);
                cc-=c[t][j];//进行下一此循环的时候，需要把cc和cw的值重置为迭代之前的值，完成回溯
                cw-=w[t][j];
            }
        }
    }
}
 
int main()
{
    int i,j;
    cin>>n;//输入部件数3
    cin>>m;//输入供应商数3
    cin>>cost;//输入限定价格4
    for(i=1; i<=n; i++)//请输入各部件的在不同供应商的重量，完成遍历输入
        for(j=1; j<=m; j++)
            cin>>w[i][j];
   
    for(i=1; i<=n; i++) //请输入各部件的在不同供应商的价格，完成遍历输入
        for(j=1; j<=m; j++)
            cin>>c[i][j];
    Backtrack(1);
    
	cout<<"每个部件的供应商："<<endl;
    for(i=1;i<=n;i++)
        cout<<bestx[i]<<' ';
    cout<<endl;
    cout<<bestw;
    return 0;
}
