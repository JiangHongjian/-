#include <stdio.h>

int n;    //物品的数量
int m;   //物品的约束条件数量
int w[100][100];  //物品的属性
int c[100];    //约束条件
int cw[100]={0};   //当前属性值
double v[100];  //物品价值
double cv=0;   //当前背包价值
double bestv=0;//当前最大的价值

void getBest(int i)
{
    int k;    
    if(i>=n)    //递归结束的判定条件，参数i等于或者超过物品数量，结束方法
        return;

    for(k=0;k<m;k++)   //对物品约束条件的数量进行遍历
        if(cw[k]+w[i][k]>c[k])   //当前属性+已选物品属性超过了属性的约束条件，则不满足约束条件，循环结束，例如：cw[0]+w[0][0]>其约束条件，return
            return ;//因为k在增长，也就是那一行逐个相加后，需要满足在约束条件的范围之内

    for(k=0;k<m;k++)   //for循环是对于不满足cw[k]+w[i][k]>c[k]这个条件的时候，则在其约束条件范围之内
    cw[k]+=w[i][k];//自身加上当前选择的物品的属性值 ，记录到当前属性值cw[]数组中，因为在main函数中c用i<m来遍历，所以这里是用i代表该行，k在for中遍历代表列放进w数组中，价值是用i<n来遍历，所以也是用参数i作为起始
    cv+=v[i];   //累加当前选择物品的价值，用当前背包价值cv记录 

    if(cv>bestv)  //如果当前背包价值>当前最大价值
        bestv=cv;   //两数交换，更新当前最大收益
    k=i+1;   //计算下一个节点要不要加入背包

    while(k<n)  //k<物品数量，即没有遍历完该行所有数据的情况下
        getBest(k++);   //对其同排右边的各节点调用函数自身，递归下去 

	//当不在约束值范围之内时
    cv-=v[i];   //回溯，之前加的物品价值回溯还原价值到上一个状态 
    for(k=0;k<m;k++)    //for跟之前一样遍历k一样，对k进行遍历后都进行回溯
        cw[k]-=w[i][k];    //对该行回溯还原属性约束到上一个状态 ，也就是清空的意思 
    getBest(i+1);   //继续选取下一个节点（层/行）求最佳 
	//当遍历完所有层（节点）时，满足递归结束判断条件，结束方法

}

int main(){
    int i,j;
    printf("请输入物品的数量n和约束条件m的个数：");
    scanf("%d %d",&n,&m);           //记录到n和m中
    printf("请输入这%d个物品的价值:\n",n);
    for(i=0;i<n;i++){     //物品数和价值数相等
        scanf("%lf",&v[i]);     //价值记录到数组v[]中，这里共n个物品
	}
    for(j=0;j<m;j++){     //以i列j行输入为例子，实现提示输入物品的属性，存到数组w[][]中
        printf("请依次输入%d个物品的第%d种属性:\n",n,j+1);             
		for(i=0;i<n;i++){
        scanf("%d",&w[i][j]);
		}
	}
	printf("请依次输入该%d个物品属性的约束值:\n",m);//输入n个物品m种约束条件数量的约束值
    for(i=0;i<m;i++){
        scanf("%d",&c[i]);
    }
	getBest(0);     //参数0，调用函数
    printf("最优价值为：%lf\n",bestv);//输出最大价值
	return 0;
}
